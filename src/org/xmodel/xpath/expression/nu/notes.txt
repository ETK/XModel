Notes

Any change to the model whether it be structure, value or variable can result in multiple notifications
being received by the expression tree for a given context. The context of a notification is made available
by the IPath, LeafValueListener or VariableScope, respectively.

The introduction of a new class to store the context with additional information would eliminate
the need to associate that information via hash table on the expression. This would require changes to
IPath, LeafValueListener and VariableScope.

One remaining problem in the redesign is how to mark the expression tree per context. Since notifications
for different contexts may appear in any order for a given expression, the state has to be maintained 
across contexts. One way of handling this problem is for each expression node to hold a set of contexts
for which it is dirty in the current atomic update. Determining whether an expression node was dirty 
would be a simple HashSet lookup where the presence of the context in the set indicated dirtiness.

Consider the following update scenario:

  Given objects A and B which are not parent/child associated.

  Update 1 (affects object A and one of its listeners alters object B)
    Update 2 (affects object B)
    End 2
  End 1

  The expression notification mechanism guarantees that only one notification will be provided for
  a given update. In the above case, the expression could get notification for both Update 1 and
  Update 2, and it should provide notifications for both. These notifications have to be provided
  within the scope of the update, however, so that the revert mechanism will work.
  
  So this means that marking the expression tree has to be performed within the scope of the
  update.
  
For a given Update, multiple contexts, multiple expression nodes get marked

Given sequence return type, what form should notifications take?